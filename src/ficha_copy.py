"""
    Документация по элементам кода:
        Что делает `os.path.join()`?

        - Это функция из модуля `os.path`, предназначенная для **безопасного и корректного объединения компонентов путей**.
        - Она принимает несколько строковых аргументов, каждый из которых — часть пути, и объединяет их в один путь.
        # Важная особенность: она **учитывает особенности операционной системы**, например, #разделители путей ("/" для Linux/Mac, "\" для Windows).
        ### Почему именно `os.path.join()`?

        - В отличие от простого сложения строк, `os.path.join()` **автоматически вставляет правильный разделитель пути**.
        - Также он **обеспечивает переносимость** кода между разными ОС.
        ### Пример использования:
        BASE_DIR = "/home/user/documents"
        filename = "example.txt"

        file_path = os.path.join(BASE_DIR, filename)
        # Результат: "/home/user/documents/example.txt" на Linux
            # Выводим путь к файлу для отладки
            print("Путь к файлу:", file_path)
    """

import os
import sys

# Получаем абсолютный путь к директории, где находится этот скрипт
SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
# os.path.abspath(__file__) возвращает абсолютный путь к текущему файлу скрипта
# os.path.dirname(...) возвращает директорию, в которой находится скрипт

# Устанавливаем базовую директорию для файлов. В данном случае — директория скрипта
BASE_DIR = SCRIPT_DIR
# Можно было бы дополнительно использовать os.path.join(SCRIPT_DIR, 'src'), если есть папка 'src'
# Но сейчас базовая директория — это текущая директория скрипта

# Выводим текущий рабочий каталог, чтобы знать, в какой папке запущен скрипт
print("Текущий рабочий каталог:", os.getcwd())

# Выводим базовую директорию для файлов, где ищутся файлы для копирования
print("Базовая директория для файлов:", BASE_DIR)

def copy_file(filename):
    # Формируем полный путь к файлу, который нужно скопировать
    file_path = os.path.join(BASE_DIR, filename)
    # Объединяем базовую директорию с именем файла, чтобы получить полный путь

    # Проверяем, существует ли указанный файл по данному пути
    if not os.path.exists(file_path):
        # Если файла нет, выводим сообщение и завершаем функцию
        print(f"Файл {filename} не найден в {BASE_DIR}")
        return

    # Создаём папку назначения, если она ещё не существует
    destination_dir = os.path.join(SCRIPT_DIR, 'destination')
    os.makedirs(destination_dir, exist_ok=True)
    # os.makedirs создаст директорию, если её ещё нет (параметр exist_ok=True)

    # Формируем полный путь к файлу назначения
    destination_path = os.path.join(destination_dir, filename)

    # Открываем исходный файл для чтения в бинарном режиме
    with open(file_path, 'rb') as src:
        # Открываем файл назначения для записи в бинарном режиме
        with open(destination_path, 'wb') as dst:
            # Читаем содержимое исходного файла и записываем его в файл назначения
            dst.write(src.read())

    # Выводим сообщение о завершении копирования
    print(f"Файл {filename} скопирован в {destination_dir}")

if __name__ == "__main__":
    # Проверяем, что скрипт запущен напрямую, а не импортирован как модуль

    # Проверяем, что передано достаточно аргументов командной строки
    if len(sys.argv) < 3:
        # Если аргументов меньше 3 (скрипт, команда, имя файла), выводим инструкцию
        print("Использование: python ficha_1.py copy <имя_файла>")
        sys.exit(1)  # Выходим с кодом ошибки 1

    # Первый аргумент после имени скрипта — команда
    command = sys.argv[1]
    # Второй аргумент — имя файла
    filename = sys.argv[2]

    # Проверяем, что команда — 'copy'
    if command == 'copy':
        # Вызов функции копирования файла
        copy_file(filename)
    else:
        # Если команда неизвестна, выводим сообщение
        print(f"Неизвестная команда: {command}")
